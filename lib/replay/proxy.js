// Generated by CoffeeScript 1.8.0
var EventEmitter, HTTP, HTTPS, ProxyRequest, ProxyResponse, Stream, URL, assert, clone,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

assert = require("assert");

EventEmitter = require("events").EventEmitter;

HTTP = require("http");

HTTPS = require("https");

Stream = require("stream");

URL = require("url");

ProxyRequest = (function(_super) {
  __extends(ProxyRequest, _super);

  function ProxyRequest(options, proxy) {
    var host, n, port, protocol, v, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    this.proxy = proxy;
    HTTP.IncomingMessage.call(this);
    this.method = (options.method || "GET").toUpperCase();
    protocol = options.protocol || "http:";
    _ref = (options.host || options.hostname).split(":"), host = _ref[0], port = _ref[1];
    port = options.port || port || (protocol === "https:" ? 443 : 80);
    this.url = URL.parse("" + protocol + "//" + (host || "localhost") + ":" + port + (options.path || "/"), true);
    this.auth = options.auth;
    this.agent = options.agent || (protocol === "https:" ? HTTPS.globalAgent : HTTP.globalAgent);
    this.headers = {};
    if (options.headers) {
      _ref1 = options.headers;
      for (n in _ref1) {
        v = _ref1[n];
        this.headers[n.toLowerCase()] = v === null || v === void 0 ? "" : v.toString();
      }
    }
  }

  ProxyRequest.prototype.flushHeaders = function() {};

  ProxyRequest.prototype.setHeader = function(name, value) {
    assert(!this.ended, "Already called end");
    assert(!this.body, "Already wrote body parts");
    this.headers[name.toLowerCase()] = value;
  };

  ProxyRequest.prototype.getHeader = function(name) {
    return this.headers[name.toLowerCase()];
  };

  ProxyRequest.prototype.removeHeader = function(name) {
    assert(!this.ended, "Already called end");
    assert(!this.body, "Already wrote body parts");
    delete this.headers[name.toLowerCase()];
  };

  ProxyRequest.prototype.addTrailers = function(trailers) {
    this.trailers = trailers;
  };

  ProxyRequest.prototype.setTimeout = function(timeout, callback) {
    if (callback) {
      setImmediate(callback);
    }
  };

  ProxyRequest.prototype.setNoDelay = function(nodelay) {
    if (nodelay == null) {
      nodelay = true;
    }
  };

  ProxyRequest.prototype.setSocketKeepAlive = function(enable, initial) {
    if (enable == null) {
      enable = false;
    }
  };

  ProxyRequest.prototype.write = function(chunk, encoding, callback) {
    assert(!this.ended, "Already called end");
    this.body || (this.body = []);
    this.body.push([chunk, encoding]);
    if (callback) {
      return setImmediate(callback);
    }
  };

  ProxyRequest.prototype.end = function(data, encoding, callback) {
    var _ref, _ref1;
    assert(!this.ended, "Already called end");
    if (typeof data === 'function') {
      _ref = [data, null], callback = _ref[0], data = _ref[1];
    } else if (typeof encoding === 'function') {
      _ref1 = [encoding, null], callback = _ref1[0], encoding = _ref1[1];
    }
    if (data) {
      this.body || (this.body = []);
      this.body.push([data, encoding]);
    }
    this.ended = true;
    if (callback) {
      setImmediate(callback);
    }
    this.proxy(this, (function(_this) {
      return function(error, captured) {
        return setImmediate(function() {
          var response;
          if (error) {
            return _this.emit("error", error);
          } else if (captured) {
            response = new ProxyResponse(captured);
            _this.emit("response", response);
            response.resume();
            if (process.version < "v0.11") {
              return response.resume();
            }
          } else {
            error = new Error("" + _this.method + " " + (URL.format(_this.url)) + " refused: not recording and no network access");
            error.code = "ECONNREFUSED";
            error.errno = "ECONNREFUSED";
            return _this.emit("error", error);
          }
        });
      };
    })(this));
  };

  ProxyRequest.prototype.flush = function() {};

  ProxyRequest.prototype.abort = function() {};

  return ProxyRequest;

})(HTTP.ClientRequest);

clone = function(object) {
  var result, x, y;
  result = {};
  for (x in object) {
    y = object[x];
    result[x] = y;
  }
  return result;
};

ProxyResponse = (function(_super) {
  __extends(ProxyResponse, _super);

  function ProxyResponse(captured) {
    ProxyResponse.__super__.constructor.call(this);
    if (process.version < "v0.11") {
      this.pause();
    }
    this.once("end", (function(_this) {
      return function() {
        return _this.emit("close");
      };
    })(this));
    this.httpVersion = captured.version || "1.1";
    this.httpVersionMajor = this.httpVersion.split(".")[0];
    this.httpVersionMinor = this.httpVersion.split(".")[1];
    this.statusCode = parseInt(captured.statusCode || 200, 10);
    this.statusMessage = captured.statusMessage || HTTP.STATUS_CODES[this.statusCode] || "";
    this.headers = clone(captured.headers);
    this.rawHeaders = captured.rawHeaders || [].slice(0);
    this.trailers = clone(captured.trailers);
    this.rawTrailers = (captured.rawTrailers || []).slice(0);
    this.connection = new EventEmitter();
    this._body = captured.body.slice(0);
  }

  ProxyResponse.prototype._read = function(size) {
    var part;
    part = this._body.shift();
    if (part) {
      this.push(part[0], part[1]);
    } else {
      this.push(null);
    }
  };

  ProxyResponse.prototype.setTimeout = function(msec, callback) {
    if (callback) {
      setImmediate(callback);
    }
  };

  ProxyResponse.notFound = function(url) {
    return new ProxyResponse({
      status: 404,
      body: ["No recorded request/response that matches " + (URL.format(url))]
    });
  };

  return ProxyResponse;

})(Stream.Readable);

module.exports = ProxyRequest;
